<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>farq::why-programming-languages-matter</title>
    <style>
        p {
            text-indent: 1em;
        }
    </style>
</head>
<body>
<h1>Why Programming Languages Matter</h1>

<p>Let us begin with a proof by contradiction. Suppose that programming languages don’t matter, so long as they’re
    Turing complete. Once the minimum mechanism of arbitrary computation has been satisfied, all languages are
    essentially the same, insofar as they are able to express all computable things. Now, suppose I ask you to write me
    a "modern" cross-platform desktop application in x86 assembly. I imagine that you would refuse this task, on the
    grounds that the choice of language would make the task unnecessarily painful, to the point of being intractable,
    even though the language is
    technically capable of eventually completing the job. Choosing a different language, such as Python or Java, would
    make this task significantly more bearable. The instant that we start choosing different languages for different
    problems we commit ourselves to the position that programming languages do indeed matter. If they didn’t, we would
    have no qualms with this task, and we would spend our days happily programming in machine code. Believing that
    Turing completeness is expressive enough is equivalent to believing that terminating in finite time is fast
    enough.</p>
<p>So, programming languages matter, but “why?” and “to what extent?”. Programming languages matter because they are the
    raw materials of computational expression. They provide the primitives, the means of combination, and the means of
    abstraction from which all computational entities are derived. They are the primary and most powerful means of
    human-computer interaction. If you’ve ever scripted a previously manual task, you’ve experienced this power
    first-hand. Programming languages matter because they are tools for the mind that convert the possible into the
    tractable, and help us see new horizons of the possible. They are the way we communicate our computational ideas to
    ourselves and others across time and space via the post-scarcity medium of pure information. They enable a new form
    of collective mind, empowered by unambiguous symbolic representation of ideas, the mechanism of mind laid bare,
    available for peer review, forking, patching, improving, and refining. They render us the gods of imagined universes
    where the only limitations are the limits of computability itself. But why does it matter to learn more than one of
    these languages? What benefits can I gain from learning new means of expressing my computational thoughts?</p>
<p>What if simply prepending two characters to any function call caused it to execute asynchronously? What if your
    compiler could infer the type-correctness of your program without you ever needing to write a single type signature?
    What if the source code of your language was written in the core data structure of your language, enabling you to
    easily write programs that write programs to arbitrary recursive depth? What if your language could make logical
    inferences over a set of facts without you specifying how? What if your language could generate unit tests for you,
    and, when it finds a failing test, could reduce this failure down to a minimum viable falsifying case? What if your
    language never allowed you to mutate the value of any variable, and was therefore able to provide you with a
    time-traveling debugger, infinite undo/redo, rendering time itself as a first-class entity in your language? What if
    I told you that all of this, and much, much more, actually exists today? Would this change the way you solve
    problems? Would this inspire you to think of new solutions to problems you had written off as intractable? Might
    this lead you to believe that rather than being at the end of our computational history, we are only now beginning
    to participate in its adolescence? Could this induce sufficient existential dread to make you question the nature of
    your computational reality?</p>
<p>It is precisely this that makes programming languages so irresistibly interesting to me: that they all make
    metaphysical claims about computational reality. They all propose an answer to the question: “what is real?” When we
    accept for too long one language’s position on this subject, we run the risk of accepting it not as truth from a
    given perspective, but rather as the Truth, final and determined. This would bring about the end of computational
    progress and the design pattern-ification of computational creativity. Such a fascist monocultural ethnostate must
    be resisted by the brave, inquisitive, and indomitable souls who commit to manifesting their unique ideas;
    unreasonable people who choose to bend the world in a new direction rather than submit to its existing awkward
    contours. It matters, how we conceive of ourselves. It matters that we see ourselves as active participants in the
    creation of history rather than “best-tool-for-the-job” wielding framework-plumbers at its end. I contend that it is
    through the use and creation of different programming languages, an embrace of polyglot diversity, that we can hope
    to think new thoughts, solve pernicious problems, and provide otherwise unattainable value. Humanity faces
    immense opportunity and incredible challenges. I submit that only through bold, creative, and reality-questioning
    polylinguistic thinking can we hope to rise to meet them.</p>
</body>
</html>