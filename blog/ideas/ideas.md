# Future Blog Ideas

## Speed Running
- programming speed run
- software usage speed run
- SPS Commerce making a functional setup speed run
- Stick to your commitments (don't bend to the arbitrary whims of others; emphasis on ARBITRARY whims of others. Do respond to proper argumentation.)

## The Anti-Ideology Ideology
- In favor of pragmatism
- Can be convinced of positions with better evidence/supporting data

## Actually Making Things
- JUnit/Java
- Web UIs
- Processing?

## Just Shut Up and Use an IDE
- They are awesome
- Reliable GoTo Declaration that just works out of the box is indispensable
- Tool integration is real nice (tools that aren't integrated can still be used, obviously)
- Can still use Vim key-bindings in most mature IDEs (IdeaVim ftw)
- Running tests is real easy (ctrl+shift+R inside of the test/class/package/whatever you want to run)
- Big thing I realized wasn't even related to IDEs
- Static Analysis tools often built-in, which is nice (but you really want to be able to run any sort of tool like that in CI)

## Static Types
- Just use them, they make you life and other people's lives better

## Operating Systems
- I use Windows at Home and Mac at Work and Linux on my servers, deal with it
- Being a zealot for a technology is fine, but you have to at least know a few cons before you start preaching it

## On Criticising Existing Systems
- Assume positive intention
- Critically inspect perceived "unnecessary complexity" or "over-engineering" before you make proclamations about them
  (Assume positive intention. What problems does that "complexity" solve? What problems does it introduce?
   Is the trade-off worth it?)
- Yes, re-invent the system, on the side, and then perhaps you'll realize why some of the initial design decisions were made
- Yes, refactor and otherwise introduce change, but focus on comprehension of existing system and back-filling of any missing tests first
- Introduce new techniques in `src/test` before introducing them to `src/main`

## On The Transition from Command Line Lifestyle to IDEs and GUIs
- Programmability and keyboard-driven control still paramount
- Stringly typed life on the command line and arbitrary parsing between pipeline steps
- Still nice that command line life has no separation between "user interface" and "API"
  (The programs you use interactively are literally the exact same ones you write scripts with)
- Discovered Selenium and now am pumped about WebUI automation
- Actual Integration vs Potential Integration
- Focus on testing and quality
- Transition into use of mainstream technologies
  (Getting older, having a kid, wanting to increase skills in directly employable areas in more limited time)

## Why Java is Good Enough for Me
- Proven libraries
- Job opportunities
- Strong preference for Static Types (Not historically always true for me personally)
- Go deep instead of wide (Hello world in 200 languages doesn't mean much)
- Still take lessons from "more advanced" languages (Clojure, Haskell, Scala)
- Java and Javascript/Typescript have INCREDIBLE IDE support (Why IDEs matter is a separate post)

## PC Gaming and Console Gaming
- Why I've gone more toward consoles lately:
  - Convenience (Also, easier to entertain my son downstairs in the living room rather than upstairs in my office)
  - Sport games (FIFA, Madden (don't judge me))
  - Racing games (Forza Horizon 4)
  - Console Exclusives (Red Dead Redemption 2 is seriously amazing)
- PC is getting older and upgrading is not a current financial priority
- As a programmer, I sit at a computer all day, and sometimes I just want to get away from the computer and it's associated hassles and just veg

## Full Stack Developer
- I have yet to meet anyone who is truly an "expert" at both backend and frontend development
- My current title is "Full Stack", but I am a total noob at frontend stuff
- Is it possible to truly achieve expert status at both?

## Autonomy
- Software Engineers that I've met that are passionate about their craft all crave one thing above all else: autonomy
- We want to make things that we are proud of, that we consider good, and that meet extremely high standards of technical excellence
- Non-visible features of software (under the amorphous umbrella of "quality") are severely neglected in the "Agile" environments I've worked in

## The Monorepo
- One massive repo for all my future explorations/evaluations/ideas
- Compare/contrast/evaluate all the various DI frameworks
- Compare/contrast/evaluate Java, Scala, Kotlin, Clojure for a few tasks
- Multi-module maven project
- One module for models (interfaces)
- Compare/contrast/evaluate Maven, Gradle, SBT, Lein
- Do graphics stuff with Processing, LWJGL
- Do some non-zero amount of Android stuff
- Compare/contrast/evaluate many different Web Frameworks
- Compare/contrast/evaluate many different Persistence Frameworks (JPA, JDBI, etc.)

## Technical TODO
- Upgrade to Windows 10
- Upgrade Mobo/CPU/RAM (32GB RAM, Ryzen of some sort for CPU)

## Buddhism
- The argument is basically this: be high out of your fucking mind all the god damn time
- They're really just about being so detached and chill that nothing really matters (Huge Freddie M./Dude from fucking Mr. Robot)
- Maybe they're right, but also, fuck that
- There's something beautiful about being emotionally invested, and inextricably attached to outcomes in the real world

## Spring
- Actually an amazing framework
- My hipster origin story
- How I ended up actually happy writing "enterprise" java (and kotlin)
- OOP really isn't all that bad after all

## ORMs Are The Shit
- I used to be all "Oh, Object Relational Impedance Mismatch!"
- But then I was all "HOLY SHIT, I'VE JUST BEEN SHITTILY REINVENTING THIS OVER AND OVER!"
- "Enterprise" Folks are quieter, but they are actually busier making really interesting and complex systems
- Getting things done and actually leveraging massive, professional communities is preferable to shit-posting about lisp
